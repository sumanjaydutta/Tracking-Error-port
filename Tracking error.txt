# Load necessary libraries
library(MASS)
library(CVXR)
library(tseries)
library(moments)
library(ggplot2)
hyret = read.csv("HD_returns.csv)

n_stocks <- ncol(hyret)
n_days <- nrow(hdret) # month returns data (full sample)
calibration_period <- 80 # 80 months calibration
risk_free_rate <- 0.0001 # Daily risk-free rate (for Sharpe ratio)

secret = hdret[,3:20]
secretmat = as.matrix(secret)
indexret <- hdret[,2]

# Initialize results
metric_days <- n_days - calibration_period
tracking_errors <- numeric(metric_days)
r_squared <- numeric(metric_days)
sharpe_ratios <- numeric(metric_days)
adf_stats <- numeric(metric_days)
error_spread <- numeric(metric_days)

# Initialize weights matrix
weights_matrix <- matrix(NA, nrow = metric_days, ncol = n_stocks)
weights_days <- numeric(metric_days)
weights_recorded_days <- 0

# Data frames to store ADF stats and R-squared values
adf_df <- data.frame(Day = numeric(0), ADF_Stat = numeric(0))
r_squared_df <- data.frame(Day = numeric(0), R_Squared = numeric(0))

# Function to store ADF statistics
store_adf <- function(day, stat) {
  data.frame(Day = day, ADF_Stat = stat)
}

# Function to store R-squared values
store_r_squared <- function(day, r_sq) {
  data.frame(Day = day, R_Squared = r_sq)
}

# Rolling 1-day forward loop
for (day in (calibration_period + 1):n_days) {
  # Define rolling calibration window
  calibration_start <- day - calibration_period
  calibration_end <- day - 1
  calibration_stock <- secretmat[calibration_start:calibration_end, ]
  calibration_index <- indexret[calibration_start:calibration_end]

  # Optimization
  weights <- Variable(n_stocks, nonneg = TRUE)
  intercept <- Variable(1) # Intercept term
  objective <- Minimize(sum_squares(calibration_index - calibration_stock %*% weights - intercept))
  constraints <- list(sum(weights) == 1)
  problem <- Problem(objective, constraints)
  result <- solve(problem)

  # Get optimized weights
  if (result$status == "optimal") { # Ensure the optimization was successful
    opt_weights <- result$getValue(weights)
    opt_intercept <- result$getValue(intercept)
    weights_recorded_days <- weights_recorded_days + 1 # Increment counter

    # Store weights for this day in the matrix
    weights_matrix[day - calibration_period, ] <- opt_weights
    weights_days[day - calibration_period] <- day
  } else {
    opt_weights <- rep(NA, n_stocks) # Store NA if optimization failed
  }

  # Calculate tracking error for the day
  portfolio_return <- log_stock_prices[day, ] %*% opt_weights + opt_intercept
  tracking_errors[day - calibration_period] <- log_index_prices[day] - portfolio_return

  # Store the error term (spread epsilon)
  error_spread[day - calibration_period] <- tracking_errors[day - calibration_period]

  # Calculate R-squared of the regression
  reg_residual <- calibration_index - calibration_stock %*% opt_weights - opt_intercept
  r_sq <- 1 - var(reg_residual) / var(calibration_index)
  r_squared[day - calibration_period] <- r_sq
  r_squared_df <- rbind(r_squared_df, store_r_squared(day, r_sq))

  # Perform ADF test on residuals
  adf_test <- adf.test(as.vector(reg_residual), alternative = "stationary")
  adf_stats[day - calibration_period] <- adf_test$statistic
  adf_df <- rbind(adf_df, store_adf(day, adf_test$statistic))

  # Calculate Sharpe Ratio for portfolio
  portfolio_returns <- diff(calibration_stock %*% opt_weights + opt_intercept)
  portfolio_excess_returns <- portfolio_returns - risk_free_rate
  sharpe_ratios[day - calibration_period] <- mean(portfolio_excess_returns) / sd(portfolio_excess_returns)
}

# Create a data frame for weights with days as rows
weights_df <- data.frame(Day = weights_days, weights_matrix)
colnames(weights_df)[2:(n_stocks + 1)] <- paste0("Stock_", 1:n_stocks)

# Summarize results
results <- data.frame(
  Metric = c("Average Tracking Error", "Volatility of Tracking Error", 
             "Skewness of Tracking Error", "Excess Kurtosis of Tracking Error",
             "Empirical P(Negative TE)", "Mean R-Squared", "Mean Sharpe Ratio", 
             "Mean ADF Statistic", "Number of Metric Days", "Number of Weight Days"),
  Value = c(
    mean(abs(tracking_errors)), # Average tracking error
    sd(tracking_errors), # Volatility of tracking error
    skewness(tracking_errors), # Skewness of tracking error
    kurtosis(tracking_errors) - 3, # Excess kurtosis of tracking error
    mean(tracking_errors < 0), # Proportion of negative tracking error
    mean(r_squared), # Average R-squared
    mean(sharpe_ratios, na.rm = TRUE), # Average Sharpe Ratio
    mean(adf_stats, na.rm = TRUE), # Average ADF Statistic
    metric_days, # Number of days where metrics were calculated
    weights_recorded_days # Number of days weights were recorded
  )
)

# Print results
print(results)

# Print weights dataframe
print(head(weights_df))

# Plot tracking errors
ggplot(data.frame(Day = seq(calibration_period + 1, n_days), Tracking_Error = tracking_errors), 
       aes(x = Day, y = Tracking_Error)) +
  geom_line(color = "blue") +
  labs(title = "Tracking Error Over Time", x = "Days", y = "Tracking Error") +
  theme_minimal()

# Plot error spread (epsilon)
ggplot(data.frame(Day = seq(calibration_period + 1, n_days), Spread = error_spread), 
       aes(x = Day, y = Spread)) +
  geom_line(color = "red") +
  labs(title = "Error Spread (Epsilon) Over Time", x = "Days", y = "Error Spread") +
  theme_minimal()

# View stored data frames
head(adf_df)      # ADF statistics for each day
head(r_squared_df) # R-squared values for each day